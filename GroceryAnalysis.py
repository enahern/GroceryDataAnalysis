# -*- coding: utf-8 -*-
"""MiniProj3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sSm8wnmy3anukI2V_dfrERKa8shZl-WM
"""

import pandas as pd
from itertools import combinations

data = pd.read_csv("Groceries_dataset.csv")


memnum = data["Member_number"]
item = data["itemDescription"]
d = {}
for i in range(0, len(memnum)):
    if memnum[i] in d:
        if item[i] not in d[memnum[i]]:
            d[memnum[i]] += [item[i]]
    else:
        d[memnum[i]] = [item[i]]

d_itemsupport = {}
for key,value in d.items():
    for item in value:
        if item in d_itemsupport:
            d_itemsupport[item] += 1
        else:
            d_itemsupport[item] = 1

##finding the frequent items
frequent_itemsets = []
for key,value in d_itemsupport.items():
    if value >= 19.38:
        frequent_itemsets += [key]

print(frequent_itemsets)

##finding the frequent item pairs
frequent_itempairs = set()
pairs = []
for i in range(len(frequent_itemsets)):
    for j in range(i+1, len(frequent_itemsets)):
        pairs+= [tuple(sorted([frequent_itemsets[i],frequent_itemsets[j]]))]

pair_support = {}
for bucket in d.values():
    bkt = set(bucket)
    for i,j in pairs:
        if (i in bkt) and (j in bkt):
            cur_pair = tuple(sorted([i,j]))
            if cur_pair in pair_support:
                pair_support[cur_pair] +=1
            else:
                pair_support[cur_pair] = 1

for key,value in pair_support.items():
    if value >= 19.38:
        frequent_itempairs.add(key)
print(frequent_itempairs)

triplet_support = {}
for bucket in d.values():
    bucket_set = set(bucket)
    frequent_items_in_bucket = bucket_set.intersection(frequent_itemsets)
    for item1, item2, item3 in combinations(frequent_items_in_bucket, 3):
        triplet = tuple(sorted([item1, item2, item3]))
        if triplet in triplet_support:
            triplet_support[triplet] += 1
        else:
            triplet_support[triplet] = 1


frequent_triplets = {triplet for triplet, count in triplet_support.items() if count >= 19.38}
print(frequent_triplets)

#items association rules
rules = []

for i in frequent_itemsets:
    for j in frequent_itemsets:
        if i != j:
            pr= tuple(sorted([i,j]))
            if pr in pair_support.keys():
                support_ij = pair_support[pr]
                support_j = d_itemsupport[j]
                support_i = d_itemsupport[i]
                conf = support_ij/support_i
                if conf >= 0.003:
                    rules.append([{i},j, conf])

for i,rule in enumerate(rules):
    print( "Rule: {} -> {}  - - - Confidence {}".format(rule[0], rule[1], rule[-1]))

#pairs association rules

for p in frequent_itempairs:
    for i in frequent_itemsets:
        if i not in p:
             tp = tuple(sorted([i, p[0], p[1]]))
             if tp in triplet_support.keys():
                support_all = triplet_support[tuple(sorted([i]+list(p)))]
                support_p = pair_support[tuple(sorted(tuple(p)))]
                support_i = d_itemsupport[i]
                conf = support_all/support_p
                if conf >= 0.003:
                    rules.append([{p[0],p[1]},i, conf])

for i,rule in enumerate(rules):
    print( "Rule: {} -> {}  - - - Confidence {}".format(rule[0], rule[1], rule[-1]))

"""In this specific scenario, the importance of this analysis is that it tells companies what items are typically bought together and what items to consider pairs, triplets, etc when trying to hold sales to increase the amount of customers or the profit. For example, if there is high confidence that people who buy peanut butter also buy jelly, then a company could increase the cost of jelly and hold a sale on the cost of peanut butter. Or manipulate the prices to optimize their desired want.

Support is very significant in finding frequent itemsets because it is the basis of finding
the frequency of each item. By determining the number of times that each item occurs throughout all
of the baskets, we can determine how many customers purchase or have purchased each item typically.
Confidence is an additional important idea to benefit, in this case, companies looking to optimize
profit on the items they are selling. Confidence reveals what items tend to be purchased together. This
information can lead companies to offer sales that would maintain or increase the amount of customers
while increasing profit. Lift is another important concept in finding frequent items and making decisions
from the data analysis. Lift reveals the strength and significance of the association rules by comparing
the observed and expected amount of purchase X leading to purchase Y. This tells us the significance of our rules. Overall, all of these techniques are joined together in order to paint a better picture of what items are frequently bought together. The support will allow us to find frequent items, the confidence and lift will show the strength of the association rules to determine the most correlated items. Again, this analysis can be used to maximize profit, to know when to restock items and how much, and to advertise better.

PCY Algorithm
"""

customers = d.values()


#  Count frequent of items
item_counts = {}
for c in customers:
    for item in c:
        if item in item_counts:
            item_counts[item] += 1
        else:
            item_counts[item] = 1

frequent_items = set()
for i, cnt in item_counts.items():
    if cnt >= 19.38:
        frequent_items.add(i)
print( frequent_items)

num_b = 16384
b_cnts = []
for i in range(num_b):
    b_cnts.append(0)


# Updating Hashing List
for cu in customers:
    for i in range(len(cu)):
        for j in range(i+1, len(cu)):
            it1, it2 = sorted([cu[i], cu[j]])
            if it1 in frequent_items and it2 in frequent_items:
                b_index = (hash(it1) + hash(it2)) % num_b
                b_cnts[b_index] += 1

print(b_cnts)

frequent_buckets = set()
for i, cnt in enumerate(b_cnts):
    if cnt >= 19.38:
        frequent_buckets.add(i)
print(frequent_buckets)

# candidate pairs from frequent buckets
candidate_pairs = set()
for c in customers:
    for i in range(len(c)):
        for j in range(i+1, len(c)):
            it1, it2 = sorted([c[i], c[j]])  # Ensure item1 < item2
            if it1 in frequent_items and it2 in frequent_items:
                b_index = (hash(it1) + hash(it2)) % num_b
                if b_index in frequent_buckets:
                    candidate_pairs.add((it1, it2))

print(candidate_pairs)

# Count the actual number of candidate pairs
pair_cnts = {}
for c in customers:
    for it1, it2 in candidate_pairs:
        if it1 in c and it2 in c:
            if (it1, it2) in pair_cnts:
                pair_cnts[(it1, it2)] += 1
            else:
                pair_cnts[(it1, it2)] = 1


frequent_pairs = set()
for p, cnt in pair_cnts.items():
    if cnt >= 19.38:
        frequent_pairs.add(p)

print(frequent_pairs)

rules = []

for i in frequent_items:
    for j in frequent_items:
        if i != j:
            pr= tuple(sorted([i,j]))
            if pr in pair_cnts.keys():
                support_ij = pair_cnts[pr]
                support_j = item_counts[j]
                support_i = item_counts[i]
                conf = support_ij/support_i
                if conf >= 0.003:
                    rules.append([{i},j, conf])
for i,rule in enumerate(rules):
  print( "Rule: {} -> {}  - - - Confidence {} ".format(rule[0], rule[1], rule[-1]))

